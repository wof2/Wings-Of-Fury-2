
material Island22: NormalMappedSpecular
{
  set_texture_alias NormalMap sand_normal.jpg
  set_texture_alias DiffuseMap sand.jpg

}





material IslandBase
{

// This is the preferred technique which uses both vertex and
	// fragment programs, supports coloured lights
	technique
	{
		// Base ambient pass
		pass
		{
			// base colours, not needed for rendering, but as information
			// to lighting pass categorisation routine
			ambient 1 1 1
			diffuse 0 0 0 
			specular 0 0 0 0 
			// Really basic vertex program
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTextureUnified
			{
			}
			
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass lighting
		{
			// base colours, not needed for rendering, but as information
			// to lighting pass categorisation routine
			ambient 0 0 0 
			
			// do this for each light
			iteration once_per_light

		
			scene_blend add

			// Vertex program reference
			vertex_program_ref Ogre/DepthShadowmap/NormalMapReceiverVP
			{
			}
			shadow_receiver_vertex_program_ref Ogre/DepthShadowmap/NormalMapReceiverVP
			{
			}

			// Fragment program
			fragment_program_ref Ogre/DepthShadowmap/NormalMapReceiverFP
			{
			}
			shadow_receiver_fragment_program_ref Ogre/DepthShadowmap/NormalMapReceiverFP
			{
			}

			// shadowmap texture will be bound by code

			// Base bump map
			texture_unit
			{
			  texture_alias NormalMap
				texture dummy.bmp
				colour_op replace
			}
			// Normalisation cube map
			texture_unit
			{
				cubic_texture nm.png combinedUVW
				tex_coord_set 1
				tex_address_mode clamp
			}

		}
		
		// Decal pass
		pass
		{
			// base colours, not needed for rendering, but as information
			// to lighting pass categorisation routine
			lighting off
			// Really basic vertex program
			vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTextureUnified
			{
				param_named ambient float4 1 1 1 1
			}
			scene_blend dest_colour zero


			texture_unit
			{
			   texture_alias DiffuseMap
				 texture sand.jpg
         // Scale the texture so, that it looks nice
         scale 0.3 0.3
			}
			
		}
		
		 // dirt pass
    pass
    {
        lighting off
        // Really basic vertex program
        vertex_program_ref Ogre/BasicVertexPrograms/AmbientOneTextureUnified
        {
          param_named ambient float4 1 1 1 1
        }
        scene_blend dest_colour zero

        // blend with former pass
        scene_blend alpha_blend

        // only overwrite fragments with the same depth
        depth_func equal

        // alpha map for the dirt
        texture_unit
        {
             texture_alias AlphaMap
            texture island_alpha.png

            // use alpha from this texture
            alpha_op_ex source1 src_texture src_texture
            // and colour from last pass
            colour_op_ex source2 src_texture src_texture
        }

        // detail texture
        texture_unit
        {
             texture_alias DiffuseMap2
            texture sand2.jpg
            scale 0.2 0.2
            // alpha blend colour with colour from last pass
            colour_op_ex blend_diffuse_alpha src_texture src_current
        }
    }

  
		
		
	}
}


material Island: IslandBase
{
  set_texture_alias NormalMap sand_normal.jpg
  set_texture_alias DiffuseMap sand.jpg
  set_texture_alias DiffuseMap2 sand2.jpg
  set_texture_alias AlphaMap island_alpha.png

}



material Islandold
{
    receive_shadows on
    transparency_casts_shadows off

    technique
    {
        // base pass
        pass
        {
            // no lighting
            //lighting on          

            texture_unit
            {
                // We use the grass texture as the base. other textures are blended over it
                texture sand.jpg
                // Scale the texture so, that it looks nice
                scale 0.3 0.3
                // Only blend colour
                //colour_op_ex source1 src_texture src_texture
            }
        }

        // dirt pass
        pass
        {
            // no lighting
            //lighting on

            // blend with former pass
            scene_blend alpha_blend

            // only overwrite fragments with the same depth
            depth_func equal

            // alpha map for the dirt
            texture_unit
            {
                texture island_alpha.png

                // use alpha from this texture
                alpha_op_ex source1 src_texture src_texture
                // and colour from last pass
                colour_op_ex source2 src_texture src_texture
            }

            // detail texture
            texture_unit
            {
                texture sand2.jpg
                scale 0.2 0.2
                // alpha blend colour with colour from last pass
                colour_op_ex blend_diffuse_alpha src_texture src_current
            }
        }

        // .... further detail passes like the former one

        // lighting pass
        pass
        {            
            ambient 0 0 0
            diffuse 1 0.980392 0.835294 1
            specular 0.1 0.1 0.1 1 0
            iteration once_per_light

            scene_blend add
            
             shadow_receiver_vertex_program_ref Ogre/DepthShadowmap/NormalMapReceiverVP
             {
             }

             shadow_receiver_fragment_program_ref Ogre/DepthShadowmap/NormalMapReceiverFP
             {
             }
        }


    }



	// Fallback
	technique
	{
		pass
		{
			ambient 1 1 1 1
			diffuse 1 0.980392 0.835294 1
			specular 0.1 0.1 0.1 1 0
			emissive 0 0 0 1
			scene_blend one zero
			depth_check on
			depth_write on
			depth_func less_equal
			depth_bias 0 0
			alpha_rejection always_pass 0
			cull_hardware clockwise
			cull_software back
			lighting on
			shading gouraud
			polygon_mode solid
			colour_write on			
			iteration once 
			texture_unit
			{
				texture sand.jpg 2d unlimited  
				binding_type fragment
				tex_coord_set 0
				tex_address_mode wrap wrap wrap
				tex_border_colour 0 0 0 1
				filtering trilinear
				max_anisotropy 1
				mipmap_bias 0
				colour_op_ex modulate src_texture src_current 1 1 1 1 1 1 1
				alpha_op_ex source1 src_texture src_current 1 1 1
				colour_op_multipass_fallback one zero
				env_map off
			}

		}

	}

}


material Lane
{
	technique
	{
		pass
		{
			ambient 1 1 1 
			diffuse 0.9 0.9 0.9
			specular 0.1 0.1 0.1 1 0
		
			texture_unit 
			{
				texture lane_low.dds
			}
		}
	}
}


material Palmtree
{
	technique
	{
		pass
		{
			ambient 1 1 1 
			diffuse 0.611765 0.666667 0.388235 
			specular 0.1 0.1 0.1 1 0
		
			texture_unit 
			{
				texture TreeTexture.jpg
			}
		}
	}
}




material FakePalmTree
{


	technique
	{
		pass
		{
			ambient 1 1 1
			diffuse 0.5 0.5 0.5			
			scene_blend alpha_blend			
			depth_write off
			lighting on	
			texture_unit
			{
				texture PalmTree.dds
			}		

		}

	}
	technique
	{
		pass
		{
			ambient 1 1 1
			diffuse 0.5 0.5 0.5			
			scene_blend alpha_blend			
			depth_write on
			lighting off	
			texture_unit
			{
				texture PalmTree.dds
			}		

		}

	}

	
}


material FakePalmTree2
{


	technique
	{
		pass
		{
			ambient 1 1 1
			diffuse 0.5 0.5 0.5			
			scene_blend alpha_blend			
			depth_write off
			lighting on	
			texture_unit
			{
				texture PalmTree2.dds
			}		

		}

	}
	technique
	{
		pass
		{
			ambient 1 1 1
			diffuse 0.5 0.5 0.5			
			scene_blend alpha_blend			
			depth_write on
			lighting off	
			texture_unit
			{
				texture PalmTree2.dds
			}		

		}

	}

	
}









// Island HLSL Material - For Hydrax demo application
// Xavier Verguín González 

vertex_program Island/VP hlsl
{
   source Island.hlsl
   entry_point main_vp
   target vs_1_1
}

fragment_program Island/FP hlsl
{
   source Island.hlsl
   entry_point main_fp
   target ps_2_0
}

material Islandold2
{
   technique
   {
      pass
      {
         // Vertex program reference
         vertex_program_ref Island/VP
         {
            param_named_auto uLightPosition light_position_object_space 0
            param_named_auto uEyePosition camera_position_object_space
            param_named_auto uWorldViewProj worldviewproj_matrix
            
            param_named uTexturesScale float 16
         }

         // Fragment program
         fragment_program_ref Island/FP
         {
            param_named_auto uLightDiffuse light_diffuse_colour 0
            param_named_auto uLightSpecular light_specular_colour 0
            // Parallax Height scale and bias
            param_named uScaleBias float4 0.04 -0.02 1 0
         }

         texture_unit
         {
            texture Sand.tga
            tex_coord_set 0
         }
         texture_unit
         {
            texture Sand.png
            tex_coord_set 1
         }

         texture_unit
         {
            texture SandGrass.tga
            tex_coord_set 2
         }
         texture_unit
         {
            texture SandGrass.png
            tex_coord_set 3
         }
      }
   }
}